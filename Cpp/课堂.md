## 9-28

class中开头没有写private/public时默认是private

有自定义的构造函数时，编译器不会再产生默认的构造函数，需要自己定义一遍，并且定义都应当写在public中。

析构函数没有参数，也不能重载

注意构造函数大括号内有无内容，从而调用构造函数时的区别：

```cpp
A a;  // 默认构造函数
A a();  // 重载构造函数，无形参，打括号内有内容
```

exit退出时，局部自动对象不能执行析构函数，静态和全局对象可以调用析构函数

abort退出时，所有对象都不能执行析构函数

析构函数的default和delete关键词？

## 9-30

using关键字？

静态union？

位段？

new的操作数为类型表达式，delete的操作数为const *类型

new/delete语法

不要多次调用析构函数(不能对一块已经自由的空间做释放)，事实上自己不需要手动调用析构函数，只需要让程序自动调用就可以。或者使用更安全的写法：

```cpp
~A(){
    if (nullptr != p)
        delete p;
    p = nullptr;
}
```

const类型的类函数事实上是不允许修改this及其指向内容(this是const类型的)

```cpp
void f1();
void f2() const{
    f1();  // 错误，f1含有隐式参数this(非const)，相当于改变了this
}
```

## 10-5

### 构造函数和析构函数

拷贝构造函数和移动构造函数

```cpp
A(A &a){};  // 拷贝构造函数，这种和下一种都可以
A(const A &a){};
A(A &&a){};  // 移动构造函数，直接将a中的部分变量移动到新的类中
```

- 没有定义时，复制构造函数可以由编译器自动产生（缺省的复制构造函数）

- 缺省的复制构造函数：调用时是浅拷贝的，在赋值情况下也是浅拷贝的

- 上面的一个错误案例：

  ```cpp
  A a1(3);
  A a2(a1);
  return 0;
  ----------------------
  析构时先析构a2，这时候由于浅拷贝事实上将a1的空间也释放了，再释放a2时反复释放内存了。
  ```

- 因此，如果复制后前一个类不再使用，建议使用移动构造函数

- 函数参数里如果有类的值传递，会调用复制构造函数，因此为了节约时间空间以及安全，应该使用传引用

- ```cpp
  A a = (5, 2)和A a(5, 2)??
  ```

初始化查看步骤：初始化列表->默认初始化值->无参初始化/零初始化
